<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Testing and Packaging JS:</h1>
					<h3>JavaScript's final frontier</h3>
					<p>
						<small>Created by <a href="http://blog.codeartgames.com">Shawn Campbell</a> / <a href="http://twitter.com/jaegerpicker">@jaegerpicker</a></small>
					</p>
				</section>
				<section>
					<h2>Who am I?</h2>
					<p>
						I'm Shawn Campbell, I've been a software engineer for the last 15 years. I've mostly worked on web applications but mobile and desktop applications
						also. I work at <a href="http://www.cashstar.com">CashStar</a> here in Portland, ME. I'm new to Maine since September 2013 and loving it so far.
						I love working with python but have used Objective-C, Java, C#, ruby, GoLang, C/C++, and Groovy professionally in the past but more than any language
						I've always worked with JavaScript.
					</p>
				</section>
				<section>
					<section>
						<h2>Let's bravefully go where no man has gone before (or at least not nearly as many as should have)</h2>
					</section>
					<section>
						<h2>Packaging? What for and why</h2>
						<p>
							Packaging has two important use cases, first dependency managment(think pip, ruby gems, or in this case npm and bower) and second building your app. There are two
							important types of libraries to worry about managing in web applications. Server side or development time libraries and client side or web app dependencies.
							Development libraries are typically used for unit testing, JS minification, JS cancatenation, or css(less/sass) complilation. Client side libs are things
							like backbone.js, ember.js, or underscore.js.
						</p>
						<p>
							Building your app is concatenating your js/css, minifying your code, and updating your templates to use the new libs. This is also the step that will compile
							CoffeeScript, ClojureScript, or TypeScript along with Less, SCSS, or Sass. The packaging tool can then package your web app up and make it much easier to
							deploy.
						</p>
					</section>
					<section>
						<h2>Unit Testing</h2>
						<p>
							Our client side javascript apps are becoming more and more complicated. Server-side developers have long placed a huge importance on automated unit testing.
							Often going as far as to break builds if the tests do not all pass, yet client side unit testing remains much less common. Testing our code should be required
							not optional, even the client side code.
						</p>
					</section>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<section>
						<h2>Task runners</h2>
						<p>
							JavaScript task runners are useful JS files that help to automate common development and server side tasks. We'll cover two options here, Grunt and Gulp.
						</p>
					</section>
					<section>
						<h2><a href="http://gruntjs.com/">Grunt.js</a> </h2>
						<p>
							Grunt is the most popular and most used task runner around today. Lots of plugins and a ton of examples on the internet. It's based on defining tasks and
							and using various node libraries to automate tasks.
						</p>
					</section>
					<section>
						<h2><a href="http://gulpjs.com/">Gulp.js</a></h2>
						<p>
							Gulp is a new and popular task runner. It's a based on node.js streams and code-over-configuration and aims to be simpliarer and quicker to use than Grunt.
							It's still very new and there are vastly fewer examples and plugins available however.
						</p>
					</section>
				</section>
				<section>
					<h2>Types of tasks</h2>
					<p>
						I usually define 5 different tasks:
						<ol>
							<li>Build</li>
							<li>server</li>
							<li>clean</li>
							<li>test</li>
							<li>test ci</li>
						</ol>
					</p>
				</section>
				<section>
					<h2>Build</h2>
					<p>
						This task typically will minify and concatenate javascript into one file. It will also compile css via less or whatever css preprocessor you have used
						in the project. This is also the step that you would compile CoffeeScript if you are using it.
					</p>
				</section>
				<section>
					<h2>Server</h2>
					<p>
						This task will start a simple html serving web server, that will autoreload any html/js/css upon change. Grunt-livereload is a great plugin to help
						with this.
					</p>
				</section>
				<section>
					<h2>Clean</h2>
					<p>
						This task will remove the compiled JS and css files form the project. It's sometimes nice to reset our app in order to avoid any wierd caching issues.
					</p>
				</section>
				<section>
					<h2>Test</h2>
					<p>
						This task will start a test runner in an interactive mode. Running the unit tests in chrome. I use testem but karma is also very popular. The test runner
						will monitor for changes in the tests and new tests being added. I try to use a practical version of TDD* and having a continual running test enviroment
						really helps me have a solid work flow.
					</p>
					<small>
						*By practical I mean I tend to layout and develop the base outline and structure of the code base prior to starting basic testing. This tends to remove
						most of the tedium of having tests fail because I haven't written any code for them yet.
					</small>
				</section>
				<section>
					<h2>Test ci</h2>
					<p>
						This task runs tests in a headless manner that is useful for continous integration. This will use PhantomJS which is a headless webkit browser to run
						tests with out interaction. This is an important step to help with a build server integration.
					</p>
				</section>
				<section>
					<h1>Testing!</h1>
				</section>
				<section>
					<h2>A note about TDD, BDD, and integration tests</h2>
					<p>
						I don't think a script TDD or BDD approach is completely neccessary to produce quality code, however I do belive that unit tests and integration tests
						are strictly neccessary for a quality code base. Here is my working definitation of Unit tests and integration tests:
						<ul>
							<li>
								Unit tests are tests that only interact with your codebase. For example no ajax calls out are actually executed, no browser apis or library apis
								called directly without wrapping code, and the test is strictly responsible for testing a small descrete section of code. I personally like to limit
								my unit tests to testing single functions were possible. It's very often neccessary to mock out external calls. I use <a href="http://sinonjs.org/">
									Sinon.js</a> to handle most of my mocking needs.
							</li>
							<li>
								Integration tests are broader and my general, system wide type of tests. An ajax call out to an external/server side API is a good example. Integration
								testing is a broader subject and I'll stick to unit testing in these slides.
							</li>
					</p>
				</section>
				<section id="transitions">
					<h2>Mochai? Chai? really the coffee names have gone far enough</h2>
					<p>
						Mocha is a Unit testing library. It uses a BDD style syntax for it's testing descrtiptions. Here is the offical tag line:
						Mocha is a feature-rich JavaScript test framework running on node.js and the browser, making asynchronous testing simple and fun. Mocha tests run serially,
						allowing for flexible and accurate reporting, while mapping uncaught exceptions to the correct test cases.
						Chai is a testing syntax helper library used to specify a declaritive/promise based assertion syntax. Offical tag line:
						Chai is a BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework.
					</p>
				</section>

				<section id="themes">
					<h2>BDD? assertations? say what!?</h2>
					<p>
						BDD - stands for Behavior driven development. Tests are written in a manner that reads like a sentence.
						In other words a test should read in this way
						<pre><code data-trim>
						test("the function getting data from the api", function(fixture_data) {
							//....do test stuff
						});
					</code></pre>
						Assertions look like this normally:
						<pre><code data-trim>
						a = 1;
						b = 2;
						assert(a == b, "This should have failed");
						// this print out the test in the second parameter
					</code></pre>
						Chai make it nicer but giving us this syntax:
						<pre><code data-trim>
						a = 1;
						b = 1;
						a.should.equal.b("This should not fail");
						//or
						expect(a).to.equal(b, 'This should not fail');
					</code></pre>
						So assertions are the indivual tests clauses of our greater tests suite.
					</p>
				</section>
				<section>
					<h2>Let's look at an examples</h2>
					<p>
						I setup a sample project using backbone.js app with mocha, chai, sinon, testem, grunt, npm, and bower.
					</p>
					<a href="http://github.com/jaegerpicker/JSUnitTestBackBone">http://github.com/jaegerpicker/JSUnitTestBackBone</a>
					<a href="http://github.com/jaegerpicker/reveal.js">http://github.com/jaegerpicker/reveal.js</a>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
